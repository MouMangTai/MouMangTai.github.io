<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《人件》读后感</title>
    <link href="/2021/10/15/%E3%80%8A%E4%BA%BA%E4%BB%B6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <url>/2021/10/15/%E3%80%8A%E4%BA%BA%E4%BB%B6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人在本质上是不可管理的，真正追求软件的成功应该让团队里的所有人热爱自己的作品</p></blockquote><span id="more"></span><h2 id="《人件》读后感"><a href="#《人件》读后感" class="headerlink" title="《人件》读后感"></a>《人件》读后感</h2><p>《人件》这本书的主要面向对象应该是一个团队或者说是软件组织的管理者。主要的核心在于强调人和机器是不同的，要把人放在一个系统中进行思考。</p><p>但是这本书的出发点却都是在为程序员考虑问题，对于一名刚刚实习没多久的我来说，我会渴望着拥有「流状态」，不被不必要的沟通所打断的自由工作环境，以及能够为了产品的质量拒绝提前交付产品的能力，这无疑是对未来踏入程序员职业的一种鼓励，让我知道一个好的团队好的环境好的企业文化是怎么样的。在充斥着「996」，「程序员35岁中年危机」的当下，有一本书能够为程序员发声，以人为本而不是以钱为本，还是非常欣慰的。</p><p>在我看来，一个好的程序员是天生是具有内在驱动力的，对于产品的质量和产品的进度并不需要其他人来督促，大多数的管理和条条框框往往都是在限制约束程序员的工作，影响人的积极性和主动性。「管理者不是让大家去工作，而是创造环境，让大家可以顺利的开展工作」，我认为管理者更应该是一个服务者，为项目的开发者去提供一个好的工作环境，减少工作打断，减少碎片化时间，或者说管理者应该是一个粘合剂，为项目的开发者去凝聚团队，营造好的工作氛围，发挥个性才能提高生产力。人在本质上是不可管理的，真正追求软件的成功应该让团队里的所有人热爱自己的作品，并且愿意拼尽全力去做好，解决人的问题，而不是钻牛角尖在技术问题上。管理，是一种服务。为了让成员快乐地、有效率地完成工作！</p><p>本文强调人和机器是不同的，不能像机器一样加了油就能一直运行，不能像电脑一样有电就能一直跑，浏览目录时我一眼就看到了我感兴趣的词条「加班」，无谓的加班并不能带来效率上的提升，甚至会拖慢项目的进度。这也提醒管理人员，加班需谨慎啊，不到项目的最后阶段，绝对不要加班。为了更快的工作，程序员不得不牺牲产品的质量和他们对自己工作的满意度，从而也会引发更多的人员流失。</p><p>很多公司都是把员工当作机器零件或者是资源，却忽略人本身的各种因素。正如当下的许多大厂完全挤压人的一点点时间和精力，来换取项目的进度和经济的收入，当资源被压榨利用完毕就抛弃掉。我觉得《人件》应该引起更多人的思考，不能在冷漠的资本主义压榨下而表现的漠不关心，不能让错误的方式成为「席卷大地的瘟疫」，应该有更多类似本书的声音出现，慢慢的形成正确的标准，这对于程序员和管理员，乃至整个行业来说都是一种良性的改变。</p><p>每个人都是一个个体，人并不仅仅为了钱而工作，成就感、舒适感都是非常重要的因素，希望自己做领导的时候能够让员工有归属感吧（啥时候能做领导呢…..)</p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode力扣刷题</title>
    <link href="/2021/10/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    <url>/2021/10/14/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>程序 = 数据结构 + 算法</p></blockquote><span id="more"></span><h2 id="力扣解题思路"><a href="#力扣解题思路" class="headerlink" title="力扣解题思路"></a>力扣解题思路</h2><h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a>23. 合并K个升序链表</h3><ul><li>利用归并(分治法)的思路</li><li>分是将问题不断分成一些小问题然后递归求解，治是将分的各个阶段结果合并</li><li>归并算法时间复杂度为nlogn<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;<br>        <span class="hljs-keyword">if</span>(lists.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> split(lists,<span class="hljs-number">0</span>,lists.length<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode split(ListNode[] lists,<span class="hljs-built_in">int</span> left,<span class="hljs-built_in">int</span> right)&#123;<br>        <span class="hljs-keyword">if</span>(left==right)&#123;<br>            <span class="hljs-keyword">return</span> lists[left];<br>        &#125;<br>        <span class="hljs-built_in">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>        ListNode l = split(lists,left,mid);<br>        ListNode r = split(lists,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> merge(l,r);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode merge(ListNode l1,ListNode l2)&#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        ListNode p = dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">null</span>&amp;&amp;l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                p.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> ListNode(l1.val);<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                p.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> ListNode(l2.val);<br>                l2 = l2.<span class="hljs-keyword">next</span>;<br>            &#125;<br>            p = p.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        p.<span class="hljs-keyword">next</span> = l1 == <span class="hljs-literal">null</span>? l2:l1;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><ul><li><p>简单模拟,重点在于定一个哑节点简化操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        dummy.<span class="hljs-keyword">next</span> = head;<br>        ListNode pre = dummy;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>&amp;&amp;cur.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>)&#123;<br>            pre.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>            cur.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = cur;<br>            pre = cur;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a>25.K个一组翻转链表</h3></li><li><p>模拟</p></li><li><p>首先定义哑节点简化操作，然后遍历长度算出需要循环的组数</p></li><li><p>每一组内的翻转都需要三个指针（pre，cur，next）来操作，固定好pre指针，每次翻转都是将next指针移动到pre后面</p></li><li><p>一组内的翻转结束后，重置pre和cur</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode reverseKGroup(ListNode head, <span class="hljs-built_in">int</span> k) &#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        dummy.<span class="hljs-keyword">next</span> = head;<br><br>        ListNode cur = dummy;<br>        <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>)&#123;<br>            total++;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">int</span> groupNum = total / k;<br>        ListNode pre = dummy;<br>        cur = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;groupNum;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;k<span class="hljs-number">-1</span>;j++)&#123;<br>                ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>                cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>                <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;<br>                pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>            &#125;<br>            pre = cur;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h3></li><li><p>从后往前找，用尽可能小的「大数」去交换前面最近的「小数」。具体为从后往前找找到第一个升序对（x1,x2),此时x1&lt;x2,x2后面的数全部为降序，即x2为顶点。此时x1就是要替换的「小数」。再反向从降序组中找到比「小数」大的数即为「大数」。</p></li><li><p>然后将「大数」后面的数全部置为升序。由于置换后降序组仍然会保持降序，所以只需要反转降序组就可以置为升序。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> nextPermutation(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-comment">//找到第一个升序对(i-1,i)</span><br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-comment">//下标i-1即为「小数」</span><br>                <span class="hljs-built_in">int</span> x1 = nums[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-comment">//再反向从降序组中找到比「小数」大的数即为「大数」。</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=i;j--)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[j]&gt;x1)&#123;<br>                        swap(nums,j,i<span class="hljs-number">-1</span>);<br>                        <span class="hljs-keyword">reverse</span>(nums,i,n<span class="hljs-number">-1</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果没找到升序对，说明整体降序，直接翻转为最小值即可。</span><br>        <span class="hljs-keyword">reverse</span>(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h3><ul><li><p>动态规划</p></li><li><p>定义dp[i]为包含下标为i在内的最长有效括号子串的长度。</p></li><li><p>当s[i]为左括号时，dp[i]为0</p></li><li><p>当s[i]为右括号时：</p><ol><li>s[i-1]为右括号，则要判断i-s[i-1]-1是否为左括号，如果是则还要加上dp[i-s[i-1]-2],如果不是则为0</li><li>s[i-1]为左括号，则加上dp[i-2]</li></ol></li><li><p>要注意下标越界的情况</p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> cs[] = s.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">int</span> n = cs.length;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(cs[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(cs[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = <span class="hljs-number">2</span> + (i<span class="hljs-number">-2</span>&gt;=<span class="hljs-number">0</span>?dp[i<span class="hljs-number">-2</span>]:<span class="hljs-number">0</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">int</span> left = i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>                    <span class="hljs-keyword">if</span>(left&gt;=<span class="hljs-number">0</span>&amp;&amp;cs[left]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                        dp[i] = <span class="hljs-number">2</span> + dp[i<span class="hljs-number">-1</span>] + (left<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>?dp[left<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            max = Math.<span class="hljs-built_in">max</span>(max,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h3><ul><li>二分查找，复杂度为logn</li><li>重点在于判断出左右哪一部分是有序的，然后根据target是不是在有序序列中来区别边界。<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]==<span class="hljs-keyword">target</span>?<span class="hljs-number">0</span>:-1;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>            <span class="hljs-keyword">int</span> m =(l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span>==nums[m])&#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>            <span class="hljs-comment">//左半部分有序</span><br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=nums[m])&#123;<br>                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=<span class="hljs-keyword">target</span>&amp;&amp;<span class="hljs-keyword">target</span>&lt;nums[m])&#123;<br>                    r = m<span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    l = m+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//右半部分有序</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(nums[m]&lt;<span class="hljs-keyword">target</span>&amp;&amp;<span class="hljs-keyword">target</span>&lt;=nums[n<span class="hljs-number">-1</span>])&#123;<br>                    l = m+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = m<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="39-组合总数"><a href="#39-组合总数" class="headerlink" title="39.组合总数"></a>39.组合总数</h3></li><li>无重复，无限制重复选取</li><li>利用dfs深度搜索</li><li>无限制重复选取只需要dfs方法传一个depth，每次遍历都将当前下标i传入进行递归。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,Stack&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>,<span class="hljs-type">int</span> depth)&#123;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>        res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=depth;i&lt;candidates.length;i++)&#123;<br>        <span class="hljs-type">path</span>.push(candidates[i]);<br>        dfs(candidates,target-candidates[i],<span class="hljs-type">path</span>,i);<br>        <span class="hljs-type">path</span>.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41.缺失的第一个正数"></a>41.缺失的第一个正数</h3><ul><li>循环遍历数组</li><li>每一个「大于0且小于等于数组长度的数」都要置换到它应在的地方</li><li>如果置换回来的数也是「大于0且小于等于数组长度的数」则要循环继续置换，并且置换回来的数不能等于原来的数，否则会陷入死循环</li><li>如果换回来的数不是「大于0且小于等于数组长度的数」则说明该下标对应的数还未遍历到</li><li>如果两个数置换后正好都处在应该在的位置，则下一次遍历nums[i]-1就是本身，就会停止<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">while</span>(nums[i]&gt;=<span class="hljs-number">1</span>&amp;&amp;nums[i]&lt;=n&amp;&amp;nums[nums[i]<span class="hljs-number">-1</span>]!=nums[i])&#123;<br>            <span class="hljs-built_in">swap</span>(nums,i,nums[i]<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]!=i+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h3><ul><li>遍历三次数组</li><li>第一次遍历：从左到右计算往左看能看到的最大柱子高度</li><li>第二次遍历：从右往左计算往右看能看到的最大柱子高度</li><li>第三次遍历：每一根柱子上所能累积的水，即当前下标左右所能看到的最大柱子高度中的较小值和当前柱子的高度差。</li><li>第二次遍历和第三次遍历可同时进行。<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> trap(<span class="hljs-built_in">int</span>[] height) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = height.length;<br>    <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">left</span> = new <span class="hljs-built_in">int</span>[<span class="hljs-built_in">n</span>];<br>    <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">right</span> = new <span class="hljs-built_in">int</span>[<span class="hljs-built_in">n</span>];<br>    <span class="hljs-built_in">left</span>[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">right</span>[<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>] = height[<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>];<br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">n</span>;i++)&#123;<br>        <span class="hljs-built_in">left</span>[i] = Math.max(<span class="hljs-built_in">left</span>[i-<span class="hljs-number">1</span>],height[i]);<br>    &#125;<br>    <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">right</span>[i] = Math.max(<span class="hljs-built_in">right</span>[i+<span class="hljs-number">1</span>],height[i]);<br>        res += Math.min(<span class="hljs-built_in">left</span>[i],<span class="hljs-built_in">right</span>[i])-height[i];<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3></li></ul><ol><li>左上角到右下角的翻转</li><li>上下对称翻转<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mel">public void <span class="hljs-keyword">rotate</span>(<span class="hljs-keyword">int</span>[][] <span class="hljs-keyword">matrix</span>) &#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-keyword">matrix</span>.length;<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">//对角线翻转</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m<span class="hljs-number">-1</span>-i;j++)&#123;<br>            <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">matrix</span>[i][j];<br>            <span class="hljs-keyword">matrix</span>[i][j] = <span class="hljs-keyword">matrix</span>[n<span class="hljs-number">-1</span>-j][m<span class="hljs-number">-1</span>-i];<br>            <span class="hljs-keyword">matrix</span>[n<span class="hljs-number">-1</span>-j][m<span class="hljs-number">-1</span>-i] = t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//左右翻转</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">matrix</span>[i][j];<br>            <span class="hljs-keyword">matrix</span>[i][j] = <span class="hljs-keyword">matrix</span>[n<span class="hljs-number">-1</span>-i][j];<br>            <span class="hljs-keyword">matrix</span>[n<span class="hljs-number">-1</span>-i][j] = t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复杂价格的设计</title>
    <link href="/2021/10/12/%E5%A4%8D%E6%9D%82%E4%BB%B7%E6%A0%BC%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/10/12/%E5%A4%8D%E6%9D%82%E4%BB%B7%E6%A0%BC%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>待完成</p></blockquote><span id="more"></span><h2 id="复杂价格的设计"><a href="#复杂价格的设计" class="headerlink" title="复杂价格的设计"></a>复杂价格的设计</h2>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2021/10/10/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2021/10/10/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>池化可以重用ByteBuf实例，高并发下，池化功能更节约内存，减少内存溢出的可能。</p></blockquote><span id="more"></span><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//服务器端的启动器，负责组装netty组件，启动服务器</span><br><span class="hljs-keyword">new</span> ServerBootstrap()<br><span class="hljs-comment">//多个组，每个组包含Boss和worker(selector+thread)</span><br>.group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br><span class="hljs-comment">//选择channel的具体实现</span><br>.channel(NioServerSocketChannel.class)<br><span class="hljs-comment">//决定worker将来能执行哪些操作</span><br>.childHandler(<br>        <span class="hljs-comment">//初始化通道，负责添加别的handler（操作）</span><br>        <span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//添加具体的handler</span><br>        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());<span class="hljs-comment">//将ByteBuf 转换为字符串</span><br>        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter()&#123; <span class="hljs-comment">//自定义handler</span><br><br>            <span class="hljs-comment">//读事件</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(msg);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//绑定监听端口</span><br>.bind(<span class="hljs-number">8282</span>);<br></code></pre></td></tr></table></figure><h4 id="客户端-同步去处理结果）"><a href="#客户端-同步去处理结果）" class="headerlink" title="客户端(同步去处理结果）"></a>客户端(同步去处理结果）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">EventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>Channel channel = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span><br>        .group(group)<br>        .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>        .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>            @Override<br>            protected void init<span class="hljs-constructor">Channel(NioSocketChannel <span class="hljs-params">nioSocketChannel</span>)</span> throws Exception &#123;<br>                nioSocketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringEncoder()</span>);<br>            &#125;<br>        &#125;)<br>        <span class="hljs-comment">//connect是异步非阻塞的，main线程发起了调用，真正执行connect是nio线程。所以下一步必须执行sync方法阻塞等待连接建立。</span><br>        <span class="hljs-comment">//否则直接跳过阻塞获取到channel，此时还未连接就会出问题。</span><br>        .connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 8282)</span>)<br>        <span class="hljs-comment">//1.使用sycn方法同步处理结果，阻塞方法，直到连接建立</span><br>        .sync<span class="hljs-literal">()</span><br>        <span class="hljs-comment">//获取channel连接对象去读写</span><br>        .channel<span class="hljs-literal">()</span>;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br>    String s = scanner.next<span class="hljs-constructor">Line()</span>;<br>    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;q&quot;</span>))&#123;<br>        <span class="hljs-comment">//同理connect方法，channel的close方法也是异步非阻塞的，需要sync同步处理结果，直到连接断开。</span><br>        ChannelFuture closeFuture = channel.close<span class="hljs-literal">()</span>;<br>        closeFuture.sync<span class="hljs-literal">()</span>;<br>        break;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">s</span>)</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//虽然主线程的连接断开了，但是还有nio的线程需要优雅的关闭。</span><br>group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br></code></pre></td></tr></table></figure><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>handler为一道工序，pipeline为流水线，多道工序合在一起就是一个流水线。</li><li>每次有一个事件发生，pipeLine就会负责发布事件，传播给每个handler，handler对自己感兴趣的事件进行处理。</li><li>eventLoop为处理数据的工人，负责管理多个channel的io操作，并且一旦工人负责了某个channel就要负责到底，即绑定。（能够保证线程安全）</li><li>eventLoop除了io操作还可以进行任务处理，并且有任务队列。</li><li>eventLoop按照pipeline里的handler顺序去处理数据。</li></ol><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><h4 id="直接内存和堆内存"><a href="#直接内存和堆内存" class="headerlink" title="直接内存和堆内存"></a>直接内存和堆内存</h4><ol><li>直接内存创建和销毁的代价昂贵，但是读写性能高，适合配合池化功能。</li><li>直接内存对GC压力小，不受JVM垃圾回收管理，但要注意主动释放。</li></ol><h4 id="池化和非池化"><a href="#池化和非池化" class="headerlink" title="池化和非池化"></a>池化和非池化</h4><ol><li>池化可以重用ByteBuf实例，高并发下，池化功能更节约内存，减少内存溢出的可能。</li><li>没有池化，每次都要创建新的实例，这种方式对直接内存代价太高，对于堆内存会增加GC压力。</li></ol><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><ol><li>UnpooledHeapByteBuf使用JVM内存，只需要等待GC回收内存。</li><li>UnpooledDirectByteBuf，需要特殊的方法来回收。</li><li>PooledByteBuf采用的池化的机制，需要更复杂的规则来回收。</li><li>因为pipeline的存在，一般需要将ByteBuf传递给下一个handler，如果在finally中release了，就失去了传递性，所以谁是ByteBuf(如果某个handler对ByteBuf进行了转换也算）最后的使用者，谁来负责release。</li></ol><h4 id="零拷贝的体现"><a href="#零拷贝的体现" class="headerlink" title="零拷贝的体现"></a>零拷贝的体现</h4><ol><li>slice方法，划分为多个ByteBuf分开进行读和修改（不能进行写操作，切片后的ByteBuf如果进行写，会影响原有的ByteBuf），但是多个ByteBuf共用的同一片内存，并没有进行数据复制。</li><li>duplicate方法，相当于截取了原始的ByteBuf的全部内容，但是用的是同一块底层内存，只是读写指针式独立的。</li><li>Unpooled.wrappedBuffer(buf1,buf2)将两个buf组合为一个buf。</li></ol><h4 id="相比较ByteBuffer的优势"><a href="#相比较ByteBuffer的优势" class="headerlink" title="相比较ByteBuffer的优势"></a>相比较ByteBuffer的优势</h4><ol><li>池化，可以重用ByteBuf实例，节约内存，减少内存溢出的可能。</li><li>读写指针分离，不需要切换读写模式。</li><li>自动扩容。</li><li>支持链式调用。</li><li>许多方法体现零拷贝。</li></ol><h3 id="双向通信的实现"><a href="#双向通信的实现" class="headerlink" title="双向通信的实现"></a>双向通信的实现</h3><p>服务端</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>.group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>)<br>.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>.child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;NioSocketChannel&gt;()</span> &#123;<br>    @Override<br>    protected void init<span class="hljs-constructor">Channel(NioSocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringDecoder()</span>);<br>        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>            @Override<br>            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                log.debug(msg.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>                ByteBuf buffer = ctx.alloc<span class="hljs-literal">()</span>.buffer<span class="hljs-literal">()</span>;<br>                buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-params">msg</span>.<span class="hljs-params">toString</span>()</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br>                ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">buffer</span>)</span>;<br>                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;)<br>.bind(<span class="hljs-number">8282</span>);<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">EventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>ChannelFuture future = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span><br>        .group(group)<br>        .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>        .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>            @Override<br>            protected void init<span class="hljs-constructor">Channel(NioSocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringEncoder()</span>);<br>                ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringDecoder()</span>);<br>                ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                    @Override<br>                    public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                        log.debug(msg.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;)<br>        .connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 8282)</span>);<br>Channel channel = future.sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br>    String s = scanner.next<span class="hljs-constructor">Line()</span>;<br>    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;q&quot;</span>))&#123;<br>        break;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">s</span>)</span>;<br>    &#125;<br>&#125;<br>ChannelFuture channelFuture = channel.close<span class="hljs-literal">()</span>;<br>channelFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>    @Override<br>    public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">channelFuture</span>)</span> throws Exception &#123;<br>        group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="粘包半包"><a href="#粘包半包" class="headerlink" title="粘包半包"></a>粘包半包</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>本质上是因为TCP是流式协议，消息无边界。</li><li>为了减少传输中的消耗，需要用算法(nagle算法，尽可能多的传输数据）进行处理而导致粘包，因为TCP传输时需要给报文加上若干字节的头部信息，即使是1个字节的信息。</li><li>MSS限制，当发送的数据超过MSS限制后，会将数据切分发送，造成半包。</li><li>应用层:接收方的ByteBuf设置的太大太小。</li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ol><li>设置一个滑动窗口大小，在窗口以内的数据可以不等待服务器响应的结果就可以直接发送。在应答未到达之前，窗口必须停止滑动。接收方也要维护一个窗口，只有落在窗口内的数据才能被接受。</li><li>滑动窗口起着缓冲区的作用和流量控制的作用。</li></ol><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol><li>短连接，发送了完整数据后就断开连接。将连接建立到连接断开作为消息边界。能解决粘包但不能解决半包，并且效率低。</li><li>定长解码器，FixedLengthFrameDecoder(和客户端约定的长度)。会造成很多内存的浪费。</li><li>分隔符来界定消息的边界，LineBasedFrameDecoder(maxLength),用\n和\r\n定界。DelimiterBasedFrameDecoder自定义分隔符。底层实现还是一个个字节去找分隔符，效率较低。</li><li>基于长度字段的LTC解码器。LengthFieldBasedFrameDecoder(最大值，长度偏移量，长度字段的长度，跳过多少字节，去掉头部多少字节)。</li></ol><h3 id="协议的设计与解析"><a href="#协议的设计与解析" class="headerlink" title="协议的设计与解析"></a>协议的设计与解析</h3><h4 id="redis协议"><a href="#redis协议" class="headerlink" title="redis协议"></a>redis协议</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">final static byte<span class="hljs-literal">[]</span> LINE = &#123;<span class="hljs-number">13</span>,<span class="hljs-number">10</span>&#125;;<br>public static void send(ByteBuf buf,String command)&#123;<br>    String<span class="hljs-literal">[]</span> words = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>    buf.write<span class="hljs-constructor">Bytes((<span class="hljs-string">&quot;*&quot;</span>+<span class="hljs-params">words</span>.<span class="hljs-params">length</span>)</span>.get<span class="hljs-constructor">Bytes()</span>);<br>    buf.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>    <span class="hljs-keyword">for</span>(String word:words)&#123;<br>        buf.write<span class="hljs-constructor">Bytes((<span class="hljs-string">&quot;$&quot;</span>+<span class="hljs-params">word</span>.<span class="hljs-params">length</span>()</span>).get<span class="hljs-constructor">Bytes()</span>);<br>        buf.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>        buf.write<span class="hljs-constructor">Bytes(<span class="hljs-params">word</span>.<span class="hljs-params">getBytes</span>()</span>);<br>        buf.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><h4 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h4><h5 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h5><ol><li>魔数: 用来第一时间判定是否为无效数据包。</li><li>版本号: 可以支持协议的升级</li><li>序列化算法: 消息正文到底采用哪种序列化反序列化方式，如json，protobuf。</li><li>指令类型：登陆，注册，单聊，群聊等业务相关。</li><li>请求序号：为了双工通信，提供异步能力。</li><li>正文长度。</li><li>消息正文：Json，xml，对象流等。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>nio</tag>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO概念和多线程优化</title>
    <link href="/2021/10/06/NIO%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
    <url>/2021/10/06/NIO%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>所谓的零拷贝是指用户态和内核态之间不存在拷贝。存在用户态到内核态的切换，但是拷贝都是发生在内核态。</p></blockquote><span id="more"></span><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><ol><li>同步阻塞IO:客户端发送请求,当服务端在等待某个操作的时候，客户端就会被阻塞,直到服务端完成请求。</li><li>同步非阻塞IO:客户端发送请求,当服务端在等待某个操作时，不会阻塞，此时客户端不断轮询去发送请求，直到服务端能够接受然后去执行。但是在执行过程中客户端依旧是阻塞的。并且循环请求消耗很多的资源。</li><li>（也是同步）多路复用:客户端在服务端未准备好执行事件的时候先阻塞，当服务端准备好后，才去发送请求。无事件阻塞，有事件执行。客户端在服务端准备期间和执行期间都是堵塞的。</li><li>同步:线程自己去获取结果（一个线程）</li><li>异步:线程自己不去获取结果，而是由其他线程送结果（至少两个线程）</li><li>异步非阻塞:客户端发送请求，通知服务端完成事件后，再通过回调方法来返回结果。</li></ol><h3 id="零拷贝优化（并非真正的0拷贝）"><a href="#零拷贝优化（并非真正的0拷贝）" class="headerlink" title="零拷贝优化（并非真正的0拷贝）"></a>零拷贝优化（并非真正的0拷贝）</h3><ol start="0"><li>所谓的零拷贝是指用户态和内核态之间不存在拷贝。存在用户态到内核态的切换，但是拷贝都是发生在内核态。</li><li>问题:JAVA的IO实际不是物理设备级别的读写，而是缓存的复制，底层还是调用操作系统的读写方法，所以JAVA的每次读写都需要进行用户态到内核态，再从内核态到用户态的切换以及缓冲区的拷贝。</li><li>优化1:可以通过DirectByteBuffer进行优化。<strong>将堆外内存映射到JVM内存中来直接访问使用</strong>。减少一次数据的拷贝。但是用户态和内核态的切换次数没有减少。</li><li>优化2:通过channel调用transferTo/transferFrom方式拷贝数据。底层调用sendFile方法，<strong>直接将数据从内核缓冲区传输到socket缓冲区不经过JAVA</strong>，减少了用户态和内核态之间的切换。</li><li>优化3:也是调用transferTo方式,相比较优化2<strong>直接将内核缓冲区的数据发送到网卡</strong>。</li></ol><h3 id="多线程优化方向"><a href="#多线程优化方向" class="headerlink" title="多线程优化方向"></a>多线程优化方向</h3><p><img src="https://gitee.com/moumangtai/pic/raw/master/16334835551232.jpg"></p><ol><li>一个boss只监听accept事件，多个woker（数量最好与cpu核数保持一致）监听读写事件。</li><li>每个selector和一个线程对应。</li></ol><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;<br>    Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;boss&quot;</span>);<br>    ServerSocketChannel ssc = ServerSocketChannel.<span class="hljs-built_in">open</span>();<br>    ssc.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>    ssc.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8282</span>));<br><br>    Selector boss = Selector.<span class="hljs-built_in">open</span>();<br>    ssc.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(boss, SelectionKey.OP_ACCEPT);<br><br>    <span class="hljs-comment">//创建固定数量的work，而不是每一次连接都创建一个work</span><br>    <span class="hljs-comment">//数量固定为cpu核数</span><br>    Worker[] workers = <span class="hljs-keyword">new</span> Worker[Runtime.<span class="hljs-built_in">getRuntime</span>().<span class="hljs-built_in">availableProcessors</span>()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; workers.length; i++) &#123;<br>        workers[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Worker</span>(<span class="hljs-string">&quot;word-&quot;</span>+i);<br>    &#125;<br>    AtomicInteger size = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicInteger</span>();<br><br>    <span class="hljs-comment">//boss线程循环监听连接事件，无连接则阻塞。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        boss.<span class="hljs-built_in">select</span>();<br>        Iterator&lt;SelectionKey&gt; iterator = boss.<span class="hljs-built_in">selectedKeys</span>().<span class="hljs-built_in">iterator</span>();<br>        <span class="hljs-keyword">while</span>(iterator.<span class="hljs-built_in">hasNext</span>())&#123;<br>            SelectionKey key = iterator.<span class="hljs-built_in">next</span>();<br>            iterator.<span class="hljs-built_in">remove</span>();<br>            <span class="hljs-keyword">if</span>(key.<span class="hljs-built_in">isAcceptable</span>())&#123;<br><br>                SocketChannel sc = ssc.<span class="hljs-built_in">accept</span>();<br>                log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;监听到连接&#123;&#125;&quot;</span>,sc.<span class="hljs-built_in">getRemoteAddress</span>());<br>                sc.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br><br>                <span class="hljs-comment">//负载均衡，循环将channel注册到不同的worker上，并执行监听读写事件。</span><br>                <span class="hljs-comment">//固定了worker的数量后，每个worker就局部变成了单线程一个selector管理多个channel。</span><br>                workers[size.<span class="hljs-built_in">getAndIncrement</span>() % workers.length].<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(sc);<br><br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span>&#123;</span><br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> Selector workSelector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> isStart = <span class="hljs-literal">false</span>;    <span class="hljs-comment">//判断是否已经启动线程</span><br><br>    <span class="hljs-comment">//任务队列，用于两个不同的线程情况下，同步不同的任务之间的顺序</span><br>    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(SocketChannel socketChannel)</span> throws IOException </span>&#123;<br>        <span class="hljs-keyword">if</span>(!isStart)&#123;<br>            thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(<span class="hljs-keyword">this</span>,name);<br>            workSelector = Selector.<span class="hljs-built_in">open</span>();<br>            thread.<span class="hljs-built_in">start</span>();<br>            isStart = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//将一个线程任务放到任务队列中，等到另一个线程中再执行</span><br>        queue.<span class="hljs-built_in">add</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                socketChannel.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(workSelector,SelectionKey.OP_READ);<br>            &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (ClosedChannelException e) &#123;<br>                e.<span class="hljs-built_in">printStackTrace</span>();<br>            &#125;<br>        &#125;);<br>        workSelector.<span class="hljs-built_in">wakeup</span>();<br>    &#125;<br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//boss线程循环监听读写事件，无连接则阻塞。</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                workSelector.<span class="hljs-built_in">select</span>();<br>                <span class="hljs-comment">//将任务队列中的任务取出执行</span><br>                Runnable task = queue.<span class="hljs-built_in">poll</span>();<br>                <span class="hljs-keyword">if</span>(task!=null)&#123;<br>                    task.<span class="hljs-built_in">run</span>();<br>                &#125;<br>                Iterator&lt;SelectionKey&gt; iterator = workSelector.<span class="hljs-built_in">selectedKeys</span>().<span class="hljs-built_in">iterator</span>();<br>                <span class="hljs-keyword">while</span>(iterator.<span class="hljs-built_in">hasNext</span>())&#123;<br>                    SelectionKey key = iterator.<span class="hljs-built_in">next</span>();<br>                    iterator.<span class="hljs-built_in">remove</span>();<br><br>                    <span class="hljs-keyword">if</span>(key.<span class="hljs-built_in">isReadable</span>())&#123;<br>                        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>                        SocketChannel channel = (SocketChannel) key.<span class="hljs-built_in">channel</span>();<br>                        <span class="hljs-keyword">int</span> read = channel.<span class="hljs-built_in">read</span>(buffer);<br>                        <span class="hljs-keyword">if</span>(read==<span class="hljs-number">-1</span>)&#123;<br>                            key.<span class="hljs-built_in">cancel</span>();<br>                        &#125;<br>                        System.out.<span class="hljs-built_in">println</span>(read);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>                e.<span class="hljs-built_in">printStackTrace</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>nio</tag>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《月下神话》读后感</title>
    <link href="/2021/10/04/%E3%80%8A%E6%9C%88%E4%B8%8B%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <url>/2021/10/04/%E3%80%8A%E6%9C%88%E4%B8%8B%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一个合理的人员配置可以用更少的人更少的成本来更高效的产出。</p></blockquote><span id="more"></span><h2 id="《月下神话》读后感"><a href="#《月下神话》读后感" class="headerlink" title="《月下神话》读后感"></a>《月下神话》读后感</h2><p>刚看到书的标题时还以为《月下神话》是一本小说，搜了搜才知道其实是一本已经畅销了几十年的编程书，主要讲述项目内部的人员配置和开发效率之间的关系。其中我对“经验法则”和“外科手术队伍”比较感兴趣，也有一些自己的看法。</p><p>“经验法则”是作者提出的在项目开发过程中的进度安排：1/3计划、1/6编码、1/4构件测试和1/4系统测试。由比例就能看出计划和测试的重要性：计划是整个项目的开头，一个产品真正能够投入市场被用户所接受，就必须要在编码之前了解清楚用户的需要和喜好，进行需求分析，项目设计；而测试则是为了保证产品的质量，让用户有更流畅的体验。所以在我看来一个好的产品在开发过程中就更应该把多的时间放在和用户有关的步骤上面，生产软件是为人服务而不是为了生产本身。当然计划和测试也能帮助到我们程序员的开发，计划让我们的编程更加有条理性和逻辑性，测试能反馈我们bug去更完善产品。虽然计划和测试是如此的重要，但是经过一段实习经历后我发现，在实际的开发过程中编码却总是占着绝大部分的时间。以我个人的经历，大多数的小公司会因为急于项目上线，并不会过多的去细致的规划产品，往往都是一期一期走着看，导致程序员在开发过程中陷入很多无谓的业务修改中，代码反复修改，越改越不容易修改，导致每一次的修改成本都在上升，陷入了业务的沼泽就没时间对代码进行优化或者重构，最终在deadline到来之时草草上线，由于缺少测试，往往都由用户来反馈bug，一个产品的失败也就在所难免了。所以经验法则还是很有参考的必要的。</p><p>“外科手术队伍”说的则是一个项目团队的人员配置，里面着重强调沟通带来的成本，强调概念的一致性和项目的一致性。一个团队不是人越多开发的效率就越高，人多了划分的模块也就多了，模块与模块之间的也就是人与人之间的交互所带来的成本也就高了，而且划分的模块之间往往具有依赖性，并不能完全的独立开发完成。而外科手术团队中外科医生负责任务的划分，避免了由于模块的分解，不同的意见导致的策略上的不一致而带来的讨论和分歧，保证了一个概念的完整性。所以一个合理的人员配置可以用更少的人更少的成本来更高效的产出。</p><p>当然我觉得并不是人多就一定不好，在一定情况下，增加人手也是可以提升或者是追回进度上的滞后，前提要分析进度落后的原因和分析增加人手是否真的能带来进度的提升，而不是面对过多的需求和落后的进度就下意识的去增加人手。</p><p>以上主要是讲述开发过程的时间配置和人员配置，未来如果我成为了一名产品经理，我一定还会重拾这本书好好品味品味。</p>]]></content>
    
    
    <categories>
      
      <category>读后感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO基础</title>
    <link href="/2021/10/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88NIO%E5%AD%A6%E4%B9%A0%EF%BC%89/"/>
    <url>/2021/10/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88NIO%E5%AD%A6%E4%B9%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>selector将非阻塞模式改进为无事件阻塞，有事件非阻塞。</p></blockquote><span id="more"></span><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="非阻塞，阻塞和多路复用"><a href="#非阻塞，阻塞和多路复用" class="headerlink" title="非阻塞，阻塞和多路复用"></a>非阻塞，阻塞和多路复用</h3><ol><li>阻塞:线程没有监听到指定的操作执行时，就会停止运行。如ServerSocketChannel.accept()和channel.read(buffer)都是阻塞方法。在单线程的情况下，服务端只能执行一轮accpet一个线程并且read客户端传来的数据，但是会阻塞在下一次的accept。所以阻塞方法只能适用在多线程的情况下。但是在多线程的情况下也会有线程太多，频繁上下文切换导致性能降低.</li><li>非阻塞:各个操作之间没有影响，可以监听多个线程的多个操作。问题在于一直循环cpu占用率很高.</li><li>多路复用:单线程情况下通过配合Selector完成对多个channel可读写事件的监控，就是多路复用。<br>Selector保证了有可连接事件时才去连接，有可读事件时才去读取，有可写事件时才去写入.</li></ol><h3 id="Selector（基于事件驱动）（多路复用）"><a href="#Selector（基于事件驱动）（多路复用）" class="headerlink" title="Selector（基于事件驱动）（多路复用）"></a>Selector（基于事件驱动）（多路复用）</h3><h4 id="1-核心代码"><a href="#1-核心代码" class="headerlink" title="1. 核心代码"></a>1. 核心代码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;<br>    <span class="hljs-comment">//1.定义Selector，管理多个channel</span><br>    Selector selector = Selector.<span class="hljs-built_in">open</span>();<br>    <br>    <span class="hljs-comment">//服务端的channel</span><br>    ServerSocketChannel ssc = ServerSocketChannel.<span class="hljs-built_in">open</span>();<br>    ssc.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>    ssc.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8282</span>));<br>    <br>    <span class="hljs-comment">//2.将ServerSocketChannel注册到selector下，参数0表示不监听任何事件，通过下一个方法进行监听</span><br>    SelectionKey sscKey = ssc.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector,<span class="hljs-number">0</span>,null);<br><br>    <span class="hljs-comment">//3.定义SelectionKey的监听事件</span><br>    sscKey.<span class="hljs-built_in">interestOps</span>(SelectionKey.OP_ACCEPT);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">//4.select方法</span><br>        <span class="hljs-comment">//当没有任何事件发生则阻塞，任一事件发生了就继续执行。</span><br>        <span class="hljs-comment">//避免了无效的空转</span><br>        selector.<span class="hljs-built_in">select</span>();<br><br>        <span class="hljs-comment">//5.处理事件,方法返回所有可用的集合事件</span><br>        <span class="hljs-comment">//利用迭代器遍历</span><br>        Iterator&lt;SelectionKey&gt; iterator = selector.<span class="hljs-built_in">selectedKeys</span>().<span class="hljs-built_in">iterator</span>();<br>        <span class="hljs-keyword">while</span>(iterator.<span class="hljs-built_in">hasNext</span>())&#123;<br>            SelectionKey curKey = iterator.<span class="hljs-built_in">next</span>();<br><br>            <span class="hljs-comment">//非常重要，解决空指针异常，当一个selectionKey上的事件都处理完了之后，nio并不会将该selectionKey从集合中除去，下次执行就会爆空指针异常，所以要手动除去。</span><br>            iterator.<span class="hljs-built_in">remove</span>();<br><br>            <span class="hljs-comment">//区分事件类型</span><br>            <span class="hljs-keyword">if</span>(curKey.<span class="hljs-built_in">isAcceptable</span>())&#123;<br>                log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;连接事件...&quot;</span>);<br><br>                <span class="hljs-comment">//6.通过SelectionKey获取到关联的channel</span><br>                ServerSocketChannel channel = (ServerSocketChannel)curKey.<span class="hljs-built_in">channel</span>();<br>                <br>                <span class="hljs-comment">//执行对应的事件</span><br>                SocketChannel sc = channel.<span class="hljs-built_in">accept</span>();<br>                sc.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br><br>                <span class="hljs-comment">//7.将SocketChannel注册到Selector中,并将buffer作为附件关联到SelectionKey,使之能够一一对应,一个channel维护一个独立的buffer,避免多线程情况下buffer中内容混乱。</span><br>                ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>                SelectionKey scKey = sc.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, <span class="hljs-number">0</span>, buffer);<br>                scKey.<span class="hljs-built_in">interestOps</span>(SelectionKey.OP_READ);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curKey.<span class="hljs-built_in">isReadable</span>())&#123;<br>                <br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;读取事件...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">//6.通过SelectionKey获取到关联的channel</span><br>                    SocketChannel channel = (SocketChannel)curKey.<span class="hljs-built_in">channel</span>();<br>                    <span class="hljs-comment">//7.获取附件的buffer</span><br>                    ByteBuffer buffer = (ByteBuffer)curKey.<span class="hljs-built_in">attachment</span>();<br>                    <span class="hljs-keyword">int</span> read = channel.<span class="hljs-built_in">read</span>(buffer);<br><br>                    <span class="hljs-comment">//如果客户端正常断开，返回值拿到-1，需要将事件取消</span><br>                    <span class="hljs-keyword">if</span>(read == <span class="hljs-number">-1</span>) &#123;<br>                        curKey.<span class="hljs-built_in">cancel</span>();<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    <span class="hljs-built_in">split</span>(buffer);<br>                    <span class="hljs-comment">//如果position和limit相同，则说明buffer已经满了</span><br>                    <span class="hljs-keyword">if</span>(buffer.<span class="hljs-built_in">position</span>()==buffer.<span class="hljs-built_in">limit</span>())&#123;<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;经过一次扩容&quot;</span>);<br>                        ByteBuffer newBuffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(buffer.<span class="hljs-built_in">capacity</span>() * <span class="hljs-number">2</span>);<br>                        buffer.<span class="hljs-built_in">flip</span>();<br>                        newBuffer.<span class="hljs-built_in">put</span>(buffer);<br>                        curKey.<span class="hljs-built_in">attach</span>(newBuffer);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = buffer.<span class="hljs-built_in">position</span>(); j &lt; buffer.<span class="hljs-built_in">limit</span>(); j++) &#123;<br>                            System.out.<span class="hljs-built_in">print</span>((<span class="hljs-keyword">char</span>)buffer.<span class="hljs-built_in">get</span>(j));<br>                        &#125;<br>                        System.out.<span class="hljs-built_in">println</span>();<br>                    &#125;<br><br><br>                &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>                    <span class="hljs-comment">//如果强制断开，进入异常，需要将事件取消</span><br>                    e.<span class="hljs-built_in">printStackTrace</span>();<br>                    curKey.<span class="hljs-built_in">cancel</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-理解"><a href="#2-理解" class="headerlink" title="2. 理解"></a>2. 理解</h4><ul><li>Selector类似于注册中心，通过selector可以获取到所有的channel。</li><li>Selector模式下有两个集合，分别为channel集合（key为selectionKey，value为channel）和事件集合（key为selectionKey，value为事件队列）。当select()方法监听到事件后，会同时添加两个到两个集合中，而当事件执行完成后，会将事件集合中当前键值对的value去除掉已经执行的事件，但是即使value为空了当前键值对也不会删除，所以每次都需要手动地去迭代器中删除key，来解决空指针异常。</li><li>selector.select()等待的是所有事件（包括未处理事件），所以不会造成一个事件阻塞而导致另外事件无法监听到的问题。问题在于事件必须处理，或者执行cancel方法，否则会一直轮询。</li><li>selector将非阻塞模式改进为无事件阻塞，有事件非阻塞。</li><li>channel通过register注册到selector,注册的同时绑定一个selectionKey,selectionKey通过interestOps监听事件,并且可以通过attach绑定buffer。</li></ul><h4 id="3-处理消息边界"><a href="#3-处理消息边界" class="headerlink" title="3. 处理消息边界"></a>3. 处理消息边界</h4><ul><li>拆包粘包:LTV或者TLV协议传输</li><li>attachment附件:channel注册时绑定对应的buffer，将一个buffer作为附件关联到selectionKey上。</li><li>channel容量不足:扩容然后作为新的附件关联到selectionKey上。</li></ul><h4 id="4-buffer大小分配"><a href="#4-buffer大小分配" class="headerlink" title="4. buffer大小分配"></a>4. buffer大小分配</h4><ol><li>先分配小的buffer，不断两倍扩容。消息连续易于处理，但是需要拷贝耗费性能。</li><li>多个数组组成buffer，一个数组不够就把多的内容写入新的数组。不连续解析复杂，但是避免了拷贝。</li></ol><h4 id="5-Select-何时不阻塞"><a href="#5-Select-何时不阻塞" class="headerlink" title="5. Select()何时不阻塞"></a>5. Select()何时不阻塞</h4><ol><li>客户端发起连接，触发accept</li><li>客户端发数据，客户端正常，异常关闭或者发送的数据大于buffer缓冲区触发1到n次读取事件。</li><li>channel可写，触发1到n次写入事件。</li><li>调用selector的wakeup()和close()方法。<h3 id="ByteBuffer-和-Channel-常用方法"><a href="#ByteBuffer-和-Channel-常用方法" class="headerlink" title="ByteBuffer 和 Channel 常用方法"></a>ByteBuffer 和 Channel 常用方法</h3></li></ol><ul><li>读取<br>从channel读取数据填充ByteBuffer。<br><code>int readBytes = channel.read(buffer)</code></li><li>写入<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">ByteBuffer buffer = ...<br>buffer.<span class="hljs-built_in">put</span>(..);<br>buffer.<span class="hljs-built_in">flip</span>();<span class="hljs-comment">//切换读模式</span><br><br><span class="hljs-keyword">while</span>(buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>    channel.<span class="hljs-built_in">write</span>(buffer);<br>    <span class="hljs-comment">//channel.write(Charset.defaultCharset().encode(&quot;hello&quot;));</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>文件传输<br><code> from.transferTo(position,size,to)</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>nio</tag>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
